---
layout: cnblog_post
title:  "long_connection_transfer_encoding"
permalink: '/misc/long_connection_transfer_encoding'
date:   2017-10-22 06:34:39
categories: misc
---

```
==============HTTP保持长连接，并能发送接收数据

==============chrome设置编码
几个重要的headers：
Content-Type
Cotnent-Length

==============
当进行长连接时，默认不断等待数据，当设置Content-Length之后，可以让客户端接收指定长度的数据，
接收到指定的长度之后，不再等待接收。

有没有断开长连接

==============多进程处理客户端socket的时候
进程会对新的socket进行“写时拷贝”，此时即使是在子进程中close了套接字，可能仍然没有关闭
应该子主进程中也对套接字进行关闭操作。

============================浏览器持续“刷新”接收数据，是因为判定数据本次没有接收完毕，而长连接
停止接收数据满足以下两者之一：
1.response指定了Content-Length, 并且接收到了相应长度的数据
2.response没有指定Content-Lenght，服务端关闭了socket

对于情况1
不会断开长连接，并且在Chrom浏览器下，每隔45s发送一次心跳包，服务端的socket如果没有关闭，则会一直保持长连接。
关闭当前浏览器窗口，则客户端主动发起“挥手”。

对于情况2
服务端关闭socket，并主动发起“挥手”，连接断开，下次再请求必须重新建立连接。而浏览器在服务端关闭之前则一直在接收数据，
并且在服务端关闭之后才显示这段时间接收到的所有的数据。
==============
另外一种情况：
如果response指定了Content-Length，但是如果服务端发送的数据长度一直没有达到指定的长度，则客户端一直等待，并不断发送心跳包确认连接状态，
在，经测试在10分钟之后，依然在发送心跳包。
==============在长连接情况下，还存在一种停止数据接收的情况：
这种情况使用于服务端返回的数据长度无法提前计算的情况，因此在这种情况下无法使用Content-Length响应头，但是又想继续保持长连接，
那么应该使用这个响应头：
Transfer-Encoding: chunked
并按照如下格式进行
第i块大小\r\nxxxxxxxx块的数据\r\n第i+1块大小\r\nxxxxxx块的数据\r\n0\r\n\r\n

============================
以上都是说的长连接的情况，即
Connection: Keep-Alive
当使用短连接，即Connection: Close时，则客户端这样接收数据：
告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了。

尽管是要求使用短连接，但是使用如果使用底层的socket实现服务端，还要有服务端决定是否先发起断开连接。

========================服务端与Connection请求头对应的响应头
响应头
Connection: Close（连接已经关闭）
Connection: Keep-Alive（连接保持着，在等待本次连接的后续请求）。
========================
另外客户端如果使用了Connection: Keep-Alive这个请求头，那么还可以设置保持连接的时间。
通过Keep-Alive头设置。
Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。
例如：Keep-Alive：300

```
