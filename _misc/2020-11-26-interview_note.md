---
layout: cnblog_post
title: interview_note
permalink: '/misc/interview_note'
date: 2020-11-26 08:37:39
show: false
categories: misc
---

# 动态语言，强类型语言
动态还是静态指的是编译器还是运行期确定类型
强类型不会发生隐式类型转换

# 鸭子类型
关注点在对象的行为，而不是类型(duck typing)
比如 file,StringIO,socket 对象都支持read/write方法(file like object)
再比如定义了 __iter__ 魔术方法的对象可以用 for 迭代

python3 新增
yield from 链接子生成器
asyncio内置库，async/await 原生协程支持异步编程
新的内置库 enum, mock, asyncio, ipaddress, concurrent.futures 等 
生成的 pyc 文件统一放到 __pycache__
一些内置库的修改。urllib, selector 等
性能优化等。。。 

可变和不可变对象
不可变对象，bool int float tuple str frozenset 作为函数参数，值传递，形参开辟新内存，复制该值
可变对象 list set dict 作为函数参数 引用传递，形参是对对象内存的引用，而实际上形参和实参指向同一块内存
可变对象作为参数，但是有默认参数：默认参数只计算一次, 因此一直引用第一次创建的那个对象

## Cpython GIL
 GIL, Global Interpreter Lock
Cpython解释器的内存管理并不是线程安全的
所以，为了保护多线程情况下对 Python 对象的访问
Cpython使用简单的锁机制避免多个线程同时执行字节码

所以同一时间多个CPU只能有一个获取了锁，只有这个CPU才能执行字节码，

影响：
 限制了程序的多核执行
同一个时间只能有一个线程执行字节码
CPU密集程序难以利用多核优势
IO期间会释放 GIL，对IO密集程序影响不大(所以对大部分Web程序影响不大)

# 如何规避GIL影响
CPU密集可以使用多进程+进程池
IO密集使用多线程/协程
cython扩展

为什么有了GIL还要关注线程安全

一个操作如果是一个字节码指令可以完成就是原子的
原子的是可以保证线程安全的
使用 dis 操作来分析字节码


# 优化程序性能
数据结构与算法优化
数据库层：索引优化，慢查询消除，批量操作减少IO，NoSQL
网络IO：批量操作，pipeline操作 减少IO


# 生成器和协程
Python2 使用生成器实现协程
程序会在yield语句挂起
使用co.send(arg) next(co) 来prime 唤起协程, 协程yield的值，会返回给send或next的调用,
a = yield 表达式， 会让a接收到send传过来的arg参数
执行之后如果没有yield语句了，程序会跑出StopIteration异常


Python3.5开始原生支持协程
await async

# 单元测试
UT == Unit Testing

三无代码 (无文档，无注释，无单元测试)

好处：
1.保证代码逻辑的正确性（甚至有些采用测试驱动开发(TDD))
2.单测影响设计，易测的代码往往是高内聚低耦合的
3.回归测试，防止改一处整个服务不可用

pytest
mock 模拟接口请求
coverage 统计测试覆盖率

正常值 边界值 异常值

# Python 内置数据结构
collections 模块
namedtuple deque(appendleft) Counter(dict) OrderedDict defaultdict


find . -name '*.pyc' -delete

# 进程 线程
进程是对运行时程序的封装，是系统资源调度和分配的基本单位 
线程是进程的子任务, cpu 调度和分配的基本单位，实现进程内并发
一个进程可以包含多个线程，线程依赖进程存在，并共享进程内存 


#  Redis如何实现分布式锁？
使用setnx实现加锁，可以同时通过expire添加超时时间
锁的 value 值可以使用一个随机的 uuid 或者特定的命名
释放锁的时候，通过uuid 判断是否是该锁，是则执行delete释放锁 

# 如何解决缓存击穿问题?
某些非常热点的数据 key过期，大量请求打到后端数据库

热点数据 key 失效导致大量请求打到数据库增加数据库压力
分布式锁：获取锁的线程从数据库拉数据更新缓存，其他线程等待
异步后台更新：后台任务针对过期的 key 自动刷新 

# 缓存穿透
大量查询不到的数据的请求落到后端数据库，数据库压力增大

由于大量缓存查不到就去数据库取，数据库也没有要查的数据
解决：对于没查到返回为 None 的数据也缓存
插入数据的时候删除相应缓存，或者设置较短的超时时间 


# 如何解决缓存雪崩问题?
缓存不可用或者大量缓存key同时失效，大量请求直接打到数据库

多级缓存：不同级别的 key 设置不同的超时时间
随机超时：key 的超时时间随机设置，防止同时超时
架构层：提升系统可用性。监控、报警完善



4. B+树
B+树是应文件系统所需而出的一种B-树的变型树.一棵m阶的B+树和m阶的
B-树的差异在于：
（1)有n棵子树的结点中含有n个关键字。
（2)所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，
且叶子结点本身依关键字的大小自小而大顺序链接。
（3)所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最
大（或最小）关键字。


建表的时候需要根据查询需求来创建索引
1.经常用作查询条件的字段(WHERE条件) 
2.经常用作表连接的字段
3.经常出现在 order by, group by 之后的字段


创建索引有哪些需要注意的？
1.非空字段 NOT NULL，Mysql 很难对空值作查询优化
2.区分度高，离散度大，作为索引的字段值尽量不要有大量相同值 (枚举值等)
3.索引的长度不要太长(比较耗费时间) 


索引什么时候失效？
记忆口诀：模糊匹配、类型隐转、最左匹配
1.以 % 开头的 LIKE 语句，模糊搜索
2.出现隐式类型转换（在 Python 这种动态语言查询中需要注意）
3.没有满足最左前缀原则
key 没办法比较的时候就会失效



slow_query_log_file 开启慢查询日志


CSRF HTTPS建立过程 
跨域问题


1.→客户端发送支持的加密协议及版本，SSL、TLS
2.←服务器端从中筛选选择合适的加密协议
3.←服务器端返回证书，证书中有公钥
4.→客户端使用根证书验证证书合法性
5.→客户端生成对称密钥，通过证书中的公钥加密，发送到服务器端
6.←服务器端使用私钥解密，获取对称密钥，使用对称密钥加密数据
7.→客户端解密数据，SSL开始通信。。。


# 并行与并发
并行性 是指两个或多个时间在同一时刻发生；
并发性 是指两个或多个事件在同一时间间隔内发生。
在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行,但在单处理机系统中，
每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。
倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，
实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可同时执行。

# 进程
为使多个程序能并发执行，系统必须分别为每个程序建立进程。操作系统的四大特征(并发、共享、虚拟、异步)也都是基于进程而形成的。简单说来，
进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，
是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息，一个进程在运行时需要一定的资源，如CPU、存储空间及I/O设备等。

由于进程拥有自己的资源，故使操作系统对进程切换的调度开销较大，20世纪80年代提出了比进程跟小的单位：现成

通常在一个进程中可以包含若干个线程，他们可以利用进程拥有的资源。在引入线程的OS中，通常都是把进程作为
分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。由于线程比进程更小，基本上不拥有系统资源，
故对它的调度所付出的开销就会小得多，能更高效地提高系统内多个程序间并发执行的程度。


# nginx 的作用
1.C-S架构模式解耦，他是一个中间层，可以随时更改绑定的服务器，可以动静态请求分流(静态缓存)
2.负载均衡，避免请求拥塞，提升并发量
3.反向代理，配合服务器集群提供了按照配置、服务地区的最有服务
4.HTTPS转发http
5.安全保护，隔离内网主机

# gunicorn作用
1.充分利用多核特性，可以通过多个work，使用多个进程提供服务，避免因某个服务阻塞或者挂掉而影响整个web应用
2.

TCP 11 中状态
https://www.cnblogs.com/qingergege/p/6603488.html